# Nested Forms

Let's say we have a `User` and that a `User` `has_many : addresses`
(an office address, a home address, etc.). An address in turn
`belongs_to` a `User`.

On the sign up form, we'd like the user to enter basic information
(name, username, password, etc.) as well as give them the opportunity
to enter multiple addresses.

We want to be able to create multiple objects in a single form. We've
done that in the context of join tables (`has_many :through`, remember
`Astronaut` and `Planet`?). But those were simple objects that just
contained a pair of ids. How do we build an associated object with
more attributes than just a pair of ids?

## `accepts_nested_attributes_for`

From the `Astronaut` example, we used the
`Astronaut#visited_planet_ids` method generated by the `has_many
:visited_planets, :through => :planet_visits` association.

We can ask Rails generate a method for us to build more complicated
associated objects. We use the method `accepts_nested_attributes_for`

```ruby
class User < ActiveRecord::Base
  attr_accessible :name, :addresses_attributes

  has_many :addresses

  # I'm looking for "the magic"
  accepts_nested_attributes_for :addresses
end

class Address
  attr_accessible :city, :country

  belongs_to :user
end
```

The class method `accepts_nested_attributes_for` takes the name of an
association (`:addresses`). It generates a new instance method:
`addresses_attributes=`.

Let's see this method in action:

```ruby
u = User.new(:name => "Houdini")

# build associated Address objects
u.addresses_attributes = [
  { :city => "San Francisco", :country => "California" },
  { :city => "Reno", :country => "Nevada" }
]

# at this point, Rails saves both `User` and associated `Address`es to
# the DB
u.save!
```

Notice that `address_attributes=` expects to receive an Array of
hashes. Each hash in the Array is passed to `Address.new` to build a
new `Address`. When we go to save the `User`, we:

0. Save the `User`,
0. Fill in the `user_id` attribute of each of the `Address`es
0. Save the `Address` objects to the DB.

## The Controller

Okay! Now that we've got `addresses_attributes=` working, it's super
easy to build associated objects in the controller. It's just the same
old code:

```ruby
class UsersController < ApplicationController
  def create
    @user = User.new(params[:user])
    if @user.save
      redirect_to user_path(@user)
    else
      flash.notice = "Submission failed. Please fix the errors below."
      render :new
    end
  end
end
```

The only thing we need to make sure is that we post an array of
`addresses_attributes` hashes. If this is contained in
`params[:user]`, then `User::new` will call
`User#addresses_attributes=` (assuming it is set
`attr_accessible`). This will build the associated objects.

So let's next focus on the form.

## Nesting the form

If we can get the form to upload an array of attribute hashes, we are
golden.

How might we do that? Well, take a look at the form below. We'll
jump right to the good stuff and skip over the basic user attributes.

```html
<form accept-charset="UTF-8" action="/users" method="post">
  <h2>Addresses</h2>

  <h3>Address 1</h3>
  <label for="user_addresses_attributes_0_city">City</label>
  <input id="user_addresses_attributes_0_city"
         name="user[addresses_attributes][0][city]" type="text" />

  <label for="user_addresses_attributes_0_state">State</label>
  <input id="user_addresses_attributes_0_state"
         name="user[addresses_attributes][0][state]" type="text" />

  <h3>Address 2</h3>
  <label for="user_addresses_attributes_1_city">City</label>
  <input id="user_addresses_attributes_1_city"
         name="user[addresses_attributes][1][city]" type="text" />

  <label for="user_addresses_attributes_1_state">State</label>
  <input id="user_addresses_attributes_1_state"
         name="user[addresses_attributes][1][state]" type="text" />

  <input name="commit" type="submit" value="Create User" />
</form>
```

Note the `name` attributes: `user[addresses_attributes][0][state]` and
`user[addresses_attributes][1][state]`.

As you should know, this will not upload an array of attributes; it
will upload **a hash of hashes**:

```ruby
{ :user => {
    # ...
    :addresses_attributes => {
      "0" => {
        :city => "San Francisco",
        :state => "California"
      },
      "1" => {
        :city => "Reno",
        :state => "Nevada"
      }
    }
  }
}
```

The Rails parameter parsing conventions will not allow you to upload
an array of hashes. However, it will let you upload a hash of
hashes. Luckily, `accepts_nested_attributes_for` will happily let you
pass a hash of hashes to `addresses_attributes=` as if it were an
array.  **The keys (0, 1, 2, etc.) are simply ignored**.

Your training is complete! Well, you can now create nested objects
through a nested form, but there are a few more things to know.

## Preventing Empty Records

In the example above, we allowed the user to create up to two
addresses, but what if the user leaves one (or both) blank?

You can handle this by passing using the `:reject_if`
option. `:reject_if` tells Rails to ignore records that are left
blank.

You can pass a `Proc` to `:reject_if` which should return `true` if
the associated record should be ignored. The most typical case is to
ignore an associated record if it is left blank (for instance, if none
of the `Address` attributes are filled out). For this very common
case, you can pass the symbol `:all_blank` as the value:

```ruby
class User < ActiveRecord::Base
  attr_accessible :addresses_attributes

  has_many :addresses

  accepts_nested_attributes_for :addresses, :reject_if => :all_blank
end
```

## References

* [Rails API on `accepts_nested_attributes_for`][rails-api-nested]
* [RailsCast on nested forms][railscast-nested]

[railscast-nested]: http://railscasts.com/episodes/196-nested-model-form-revised?view=asciicast
[rails-api-nested]: http://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html
