# First Routes & Controllers

## First Routes

Go to `config/routes.rb` and generate your first routes with:

```
resources :users
```

Remember that this one line actually generates 7 routes for us.
Run `rake routes` to see what those routes are.

Woohoo! We've set up our first 7 *API endpoints*. Each route you have
is an API endpoint, which encapsulates a single action your app can
take.

Lest you scream 'magic!', do the following:

  * Comment out the `resources :users` line
  * Write out the 7 routes using the route 'matching' syntax.
    For example,

    `get 'users/:id' => 'Users#show'`

Run `rake routes` again and ensure that the routes you've written
match exactly the routes generated by the `resources` helper.

We have our initial routes now and have the endpoints necessary to
manage a User resource. Notice though that our routes point to a
`UsersController`, which we don't actually have yet.

## First Controller

If each API endpoint CRUDs a resource, and the router defines what those
endpoints are and which controller and which action in that controller
each endpoint maps to, then the controllers and their actions are the
ones actually doing the CRUDing.

Generate your first controller with:

```
$ rails generate controller Users
```

Note that controllers are usually plural, and they will usually be
managing a single collection of *resources*. A resource is anything in
your application that you will be CRUDing (creating, reading, updating,
destroying). If you remember your REST principles, that should cover
everything in your application.

Let's go take a look at the controller that was generated.

```
class UsersController < ApplicationController
end
```

Controllers inherit from `ApplicationController` which is a controller
itself, but one that never actually handles any requests directly.
`ApplicationController` is where you'd put helper methods that you want
to share across all controllers. Take a look at it (it's right there
in the `controllers/` folder):

```
class ApplicationController < ActionController::Base
  protect_from_forgery
end
```

You should be able to guess what `ActionController::Base` generally
does: it provides all the bells & whistles that Rails controllers have.
All your controllers will have all the features it provides since it
is in the inheritance chain (`UsersController` <
`ApplicationController` < `ActionController::Base`).

`protect_from_forgery` helps protect against cross-site request forgery
(CSRF) by checking the authenticity of a certain token for POST
requests. We won't worry about that for now.

Alright, now that we have some routes and a matching controller, we have
everything we need to start handling requests.

## First Launch

We have our API endpoints setup and they map to a controller which we've
created. How do we actually start taking requests?

```
$ rails server
=> Booting WEBrick
=> Rails 3.2.13 application starting in development on http://0.0.0.0:3000
=> Call with -d to detach
=> Ctrl-C to shutdown server
```

Rails ships with a lightweight web server called WEBrick.

As you can see, it loads your application in development mode (later
we'll discuss the other two modes: production and testing), and is
listening for requests at `http://0.0.0.0:3000`. The last part, `:3000`
specifies the port it is listening on. Rails defaults to port 3000 in
development. The domain  `http://0.0.0.0` can be accessed from your
browser as simply `http://localhost`.

In your browser, navigate to `http://localhost:3000`. Voila! A
running Rails app with what will become a very familiar index page.

## First Request

Create a script in your `scripts/` folder. We'll be using it to make
requests to our Rails app. Note that since we'll be interacting with
the app itself as though we were an outside party, we won't be running
this script with `rails runner`. Just run this script with the
`ruby` command.

Require `addressable/uri` and `rest-client` so that we can construct
our requests.

```
url = Addressable::URI.new(
  scheme: 'http',
  host: 'localhost',
  port: 3000,
  path: '/users'
).to_s

RestClient.get(url)
```

Make sure your server is still running (keep it in a tab in Terminal).
Now run this script and go check your server logs.

Looks like a request came in:

```
Started GET "/users" for 127.0.0.1 at 2013-06-04 07:12:34
```

But it errored out on us.

The server log will be where you'll go to see what's going on in your
application. It acts as your `STDOUT`, so all `puts` and `p` statements
in your application will also go to the server log. We'll see what
some of the most important information is in just a second.

What's the error? It seems like it's complaining that we don't actually
have an `index` action setup in our `UsersController`. Note that your
application looked for an index action because the router specified that
a GET request to /users maps to UsersController#index.

Let's fix it. Add an empty `index` action to your `UsersController`:

```
def index

end
```

Try again.

Uh oh. Another error.

This time, it's complaining that there's a missing template. Wait a
minute; we never called `render`. Why is it trying to look for a
template? Because in the absence of an explicit `render` statement,
your controller will by default try to render a template by the same
name as the controller action - in this case, it was looking for a
template called `index.html.erb` in `views/users/`.

We're not going to deal with views and templates just yet. To get rid
of this error, let's just add a simple render:

```
def index
  render :text => "I'm in the index action!"
end
```

Try again. Now take a look at the server log.

```
Started GET "/users" for 127.0.0.1 at 2013-06-04 07:21:55 -0700
Processing by UsersController#index as XML
  Rendered text template (0.0ms)
Completed 200 OK in 11ms (Views: 10.4ms | ActiveRecord: 0.0ms)
```

For every request, the server will tell you which controller and action
is processing it. In this case, it was the `UsersController`'s `index`
action.

But why is it processing as XML? Well, we're not making the request
from a browser, which would make Rails default to processing the
request as HTML. So Rails instead defaulted to XML. Let's fix that by
making it explicit in our request.

```
url = Addressable::URI.new(
  scheme: 'http',
  host: 'localhost',
  port: 3000,
  path: '/users.json'   # <== Specify the format like so
).to_s
```

If you noticed when you ran `rake routes`, at the end of each route
is `(.:format)`. The parentheses means that that part of the route is
optional. If you specify `.json`, `:format` will be `json`; `.xml`
will make it `xml`, and so on.

Try again. Looks like it is now processing it as JSON, which is what
we'll want today.

Woohoo! Your RestClient call should have returned the string "I'm in the
index action!" Victory is yours. Congratulations on successfully setting
up, making, and processing your first Rails request.

## Playing with Parameters

Now we're going to focus on how data comes into our controllers from
the outside world.

The key method here is `params`. `params` is a method provided by
`ActionController::Base` that returns a hash of all the parameters
available. The parameters are sourced from three places:

  * Route matchers (e.g. the `:id` from `/users/:id`)
  * Query string (already parsed into key-value pairs)
  * POST request data (also already parsed)

Go ahead and make some GET requests to `/users` playing around with
the query values. Check out the server log and notice that it logs
how the parameters are coming in:

```
Started GET "/users?my_param_1=my_value_1" for 127.0.0.1 at 2013-06-04 07:30:01 -0700
Processing by UsersController#index as XML
  Parameters: {"first parameter"=>"first_value"}
  Rendered text template (0.0ms)
Completed 200 OK in 0ms (Views: 0.2ms | ActiveRecord: 0.0ms)
```

Now make some POST requests to `/users` playing around with POST data
and seeing how the parameters come in. Think about what controller
action you need to POST to `/users` (check your routes again).

Now make a couple requests to `UsersController#show` and see how the
`:id` parameter comes in.

### Nesting Parameters

Notice how all of our parameters come in at the top level of the
parameters hash. Let's say we wanted to structure it a bit differently
so that certain parameters came in nested under others (hash within
a hash) like so:

```
{
  'id' => 5,
  'some_category' => {
    'a_key' => 'another value',
    'a_second_key' => 'yet another value',
    'inner_inner_hash' => {
      'key' => 'value'
    }
  },
  'something_else' => 'aaahhhhh'
}
```

Here's how we would accomplish that:

```
url = Addressable::URI.new(
  scheme: 'http',
  host: 'localhost',
  port: 3000,
  path: '/users/5.json',
  query_values: {
    'some_category[a_key]' => 'another value',
    'some_category[a_second_key]' => 'yet another value',
    'some_category[inner_inner_hash][key]' => 'value',
    'something_else' => 'aaahhhhh'
  }
)
```

If we follow this bracket notation, Rails will nest parameters for us.

Try it out a few times with both GETs and POSTs.

## Rendering JSON

For a few requests, play around with rendering JSON.

```
render :json => {'a_key' => 'a value'}
```

*NB: Note that the reason we tend to keep keys in JSON and query strings
devoid of spaces and other special characters is because Rails allows us
to key into `params` with symbols, even if the keys are strings. So, if
the key is "id" in params, you can get at it with `params[:id]`. If you
had spaces in the key, you could not use this symbol construction.*

Also play around with the `to_json` method that Rails adds to the
`Object` class. See how various Ruby data structures are converted
to JSON.

## Mixing in Models

So, now we know how to set up routes, how to set up matching controller
actions, how to send and process incoming data through parameters, and
how to render something back to the requestor. Let's mix in some models.

Build a `User` model with name and email.

*NB: Up to now we've been generating migrations and models separately,
but Rails has powerful generators. Try out:*

```
rails generate model User name:string email:string
```
*Check out the migration and model it creates for you. Use this
construction from now on.*

Migrate your database and add a couple users.

In your `UsersController#index`, grab all the users and render them
as JSON.

Remember that when you hand `render :json =>` anything, it automatically
calls `to_json` on it for you.

Make the request in your script and make sure you're getting the right
JSON back. Check your server log and note that the SQL that ran is
logged there for you. All SQL queries your app makes will show up in
the server log - yet another useful piece of information that the log
contains.

Congrats! Applications, and especially web APIs, are all about
connecting data in your database with the outside world. You've just
done that.

Note that it is common but by no means required to have one controller
map to one model. Not every model will necessarily have a controller
and not every controller will necessarily have a model.

### Creating a User through the API

Here's a very common pattern for a `create` action:

```
def create
  user = User.new(params[:user])
  if user.save
    render :json => user
  else
    render :json => user.errors, status: :unprocessable_entity
  end
end
```

*NB: Always remember to include a sensible status code. By default,
it will be 200, but if something has gone wrong, use a good status
code. In this case, it will have a status code of 422. Rails gives
us names for these various codes so that the code is a bit more
semantic. Here is a list of the [Rails status code names][rails-codes].

[rails-codes]: http://www.codyfauser.com/2008/7/4/rails-http-status-code-to-symbol-mapping

Use this as your create action and construct the params coming in so
that they're namespaced under `:user`. Mass assignment in controllers is
where nesting params becomes really nice.

Notice that we render the errors if something goes wrong along with
a status code that indicates such. In a real Rails application, you
should never be calling `save` or `update_attributes` or `create`
without having some conditional to handle the failure case. We handle
it above by rendering the errors which is a common pattern.

Add a validation or two on your User model and send in a couple requests
that should fail and see what's returned to you.

Now build all the other controller actions (except for new and edit)
and play around with them. Think about what each action's purpose is,
what data is coming in (params), what your controller needs to do with
models, and what it ultimately should render.

*NB: Why not new and edit? Because new and edit are helper actions for
create and update in the context of an HTML-based application. New
would render you the HTML page with a form to create a user (which
would then POST to /users and go to the create action). Same thing
for edit - renders a form which then will PUT to /users/5 and go to
the update action. We're working with JSON for now so there is no
form to deal with.*
